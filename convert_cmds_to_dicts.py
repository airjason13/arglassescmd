#!/usr/bin/env python3
"""
convert_cmds_to_dicts.py

Read a Python source file, find the section that starts with the comment "# SPECIAL CMD",
collect all string assignment definitions after that point into a CMD_TOTAL dict, and
also collect per-section dicts for each comment header (e.g. "# GET_CMD_VERSION" -> GET_CMD_VERSION dict).

Usage:
    python convert_cmds_to_dicts.py input_file.py [-o output_file.py]

If -o is omitted the generated dict-block will be printed to stdout.

Behavior notes:
- A "section header" is any line that begins with "#" (after trimming left whitespace) and is NOT the exact "# SPECIAL CMD" line.
- A string definition is an assignment of the form NAME = "value" or NAME = 'value' (whitespace tolerant).
- CMD_TOTAL will contain ALL string definitions found after the "# SPECIAL CMD" marker.
- Each section dict will contain the definitions found between that section header and the next section header (or EOF).

"""

import argparse
import re
import sys
from pathlib import Path

ASSIGN_RE = re.compile(r"""^\s*([A-Za-z_][A-Za-z0-9_]*)\s*=\s*(['"])(.*?)\2\s*(?:#.*)?$""")
SECTION_RE = re.compile(r"^\s*#\s*(.+?)\s*$")
SPECIAL_MARKER = "SPEC_CMD"


def sanitize_identifier(s: str) -> str:
    """Convert arbitrary section title to a safe Python identifier.
    Example: "GET-CMD VERSION" -> "GET_CMD_VERSION". If it starts with a digit, prefix underscore.
    """
    # keep letters, digits, and underscore; replace other runs with underscore
    t = re.sub(r"[^0-9a-zA-Z_]+", "_", s.strip())
    if not t:
        t = "SECTION"
    if t[0].isdigit():
        t = "_" + t
    return t


def parse_file(path: Path):
    """Parse the file and return (all_defs, sections)

    all_defs: list of (name, value, line_no)
    sections: list of (section_title, list of (name, value, line_no))
    """
    with path.open("r", encoding="utf-8") as f:
        lines = f.readlines()

    # find SPECIAL MARKER line index
    start_idx = None
    for i, line in enumerate(lines):
        m = SECTION_RE.match(line)
        if m and m.group(1).strip() == SPECIAL_MARKER:
            start_idx = i + 1
            break
    if start_idx is None:
        raise RuntimeError(f"Could not find '# {SPECIAL_MARKER}' marker in {path}")

    all_defs = []
    sections = []
    current_section = None

    for i in range(start_idx, len(lines)):
        line = lines[i]
        sec = SECTION_RE.match(line)
        if sec:
            title = sec.group(1).strip()
            # skip the SPECIAL CMD marker itself (already handled)
            if title == SPECIAL_MARKER:
                continue
            current_section = (title, [])
            sections.append(current_section)
            continue

        assign = ASSIGN_RE.match(line)
        if assign:
            name, _, val = assign.group(1), assign.group(2), assign.group(3)
            all_defs.append((name, val, i + 1))
            if current_section is not None:
                current_section[1].append((name, val, i + 1))
    return all_defs, sections


def render_output(all_defs, sections, out_path: Path | None = None):
    """Render Python code that defines CMD_TOTAL and per-section dicts.
    If out_path is provided, write to that file; otherwise return string.
    """
    lines = []
    lines.append("# Auto-generated dicts from SPECIAL CMD section")
    lines.append("# Generated by convert_cmds_to_dicts.py")
    lines.append("")

    # CMD_TOTAL
    lines.append("CMD_TOTAL = {")
    for name, val, lineno in all_defs:
        lines.append(f"    \"{name}\": \"{val}\",  # line {lineno}")
    lines.append("}")
    lines.append("")

    # Per-section dicts
    for title, items in sections:
        ident = sanitize_identifier(title)
        lines.append(f"# Section: {title}")
        lines.append(f"{ident} = {{")
        if items:
            for name, val, lineno in items:
                lines.append(f"    \"{name}\": \"{val}\",  # line {lineno}")
        lines.append("}\n")

    out_text = "\n".join(lines)

    if out_path:
        out_path.write_text(out_text, encoding="utf-8")
        return None
    return out_text


def main():
    p = argparse.ArgumentParser(description="Convert SPECIAL CMD string defs into dicts")
    p.add_argument("input", type=Path, help="input python file to scan")
    p.add_argument("-o", "--output", type=Path, help="optional output file to write generated dicts")
    args = p.parse_args()

    try:
        all_defs, sections = parse_file(args.input)
    except Exception as e:
        print("Error:", e, file=sys.stderr)
        sys.exit(2)

    result = render_output(all_defs, sections, args.output)
    if result is not None:
        print(result)
    else:
        print(f"Wrote generated dicts to {args.output}")


if __name__ == "__main__":
    main()
